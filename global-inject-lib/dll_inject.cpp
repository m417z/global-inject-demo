#include "stdafx.h"
#include "dll_inject.h"
#include "logger.h"

extern HINSTANCE g_hDllInst;

namespace
{
#define PRE_X32SHELLCODE_ARGS_3_TO_1 \
	"\x58"         /* pop eax   */ \
	"\x59"         /* pop ecx   */ \
	"\x83\xC4\x08" /* add esp,8 */ \
	"\x51"         /* push ecx  */ \
	"\x50"         /* push eax  */

#define PRE_X32SHELLCODE_VIRTUAL_FREE \
	"\xFF\x74\x24\x04"         /* push dword ptr ss:[esp+4]  */ \
	"\xE8\x1E\x00\x00\x00"     /* call $+1E                  */ \
	"\x85\xC0"                 /* test eax,eax               */ \
	"\x75\x03"                 /* jne $+3                    */ \
	"\xC2\x04\x00"             /* ret 4                      */ \
	"\x59"                     /* pop ecx                    */ \
	"\x5A"                     /* pop edx                    */ \
	"\x68\x00\x80\x00\x00"     /* push 8000                  */ \
	"\x6A\x00"                 /* push 0                     */ \
	"\xE8\x00\x00\x00\x00"     /* call $                     */ \
	"\x66\x81\x24\x24\x00\xF0" /* and word ptr ss:[esp],F000 */ \
	"\x51"                     /* push ecx                   */ \
	"\xFF\xE0"                 /* jmp eax                    */

	// The 32-bit InjectShellcode function from the project in the inject-shellcode subfolder.
	const BYTE x32APCShellcode[] =
		PRE_X32SHELLCODE_ARGS_3_TO_1
		PRE_X32SHELLCODE_VIRTUAL_FREE
		"\x55\x8B\xEC\x81\xEC\x88\x00\x00\x00\x33\xC0\xC7\x45\xA4\x49\x6E\x6A\x65\x89\x45\xF4\x33\xC9\x89\x45\xF8\x89\x45\xD4\x64\xA1\x30"
		"\x00\x00\x00\xC7\x45\xA8\x63\x74\x49\x6E\x66\xC7\x45\xAC\x69\x74\xC6\x45\xAE\x00\x8B\x50\x0C\x8B\x42\x14\x83\xC2\x14\x53\x33\xDB"
		"\xC7\x45\xE0\x00\x00\x00\x00\xC7\x45\xDC\x00\x00\x00\x00\xC7\x45\xD8\x00\x00\x00\x00\x89\x4D\xFC\x89\x5D\xF0\x89\x95\x7C\xFF\xFF"
		"\xFF\x89\x45\xE4\x56\x57\x3B\xC2\x0F\x84\x3A\x04\x00\x00\xEB\x03\x8B\x45\xE4\x8B\x70\x28\x33\xC9\x0F\xB7\x50\x24\x8D\x64\x24\x00"
		"\x0F\xB6\x3E\xC1\xC9\x0D\x80\x3E\x61\x72\x03\x83\xC1\xE0\x81\xC2\xFF\xFF\x00\x00\x03\xCF\x46\x66\x85\xD2\x75\xE4\x81\xF9\x5B\xBC"
		"\x4A\x6A\x0F\x85\x37\x01\x00\x00\x8B\x45\xE4\xBB\x08\x00\x00\x00\x8B\x70\x10\x8B\x46\x3C\x8B\x54\x30\x78\x8B\x44\x32\x20\x03\xD6"
		"\x03\xC6\x89\x55\x80\x89\x45\xE8\x8B\x4A\x24\x8B\x7A\x18\x03\xCE\x89\x4D\xEC\x85\xFF\x0F\x84\x01\x01\x00\x00\x8B\x10\x03\xD6\x33"
		"\xC0\x8A\x0A\xC1\xC8\x0D\x8D\x52\x01\x0F\xBE\xC9\x03\xC1\x8A\x0A\x84\xC9\x75\xEF\x3D\xA4\x4E\x0E\xEC\x74\x35\x3D\xAA\xFC\x0D\x7C"
		"\x74\x2E\x3D\xA0\xD5\xC9\x4D\x74\x27\x3D\xAC\x33\x06\x03\x74\x20\x3D\x66\x19\xDA\x75\x74\x19\x3D\xBC\x22\x0D\x47\x74\x12\x3D\xFB"
		"\x97\xFD\x0F\x74\x0B\x3D\x7C\xC4\x22\x59\x0F\x85\x95\x00\x00\x00\x8B\x4D\xEC\x0F\xB7\x11\x8B\x4D\x80\x8B\x49\x1C\x8D\x0C\x91\x03"
		"\xCE\x3D\xA4\x4E\x0E\xEC\x75\x09\x8B\x01\x03\xC6\x89\x45\xE0\xEB\x6E\x3D\xAA\xFC\x0D\x7C\x75\x09\x8B\x01\x03\xC6\x89\x45\xDC\xEB"
		"\x5E\x3D\xA0\xD5\xC9\x4D\x75\x09\x8B\x01\x03\xC6\x89\x45\xD8\xEB\x4E\x3D\xAC\x33\x06\x03\x75\x09\x8B\x01\x03\xC6\x89\x45\xFC\xEB"
		"\x3E\x3D\x66\x19\xDA\x75\x75\x09\x8B\x01\x03\xC6\x89\x45\xF4\xEB\x2E\x3D\xBC\x22\x0D\x47\x75\x09\x8B\x01\x03\xC6\x89\x45\xF0\xEB"
		"\x1E\x3D\xFB\x97\xFD\x0F\x75\x09\x8B\x01\x03\xC6\x89\x45\xF8\xEB\x0E\x3D\x7C\xC4\x22\x59\x75\x07\x8B\x01\x03\xC6\x89\x45\xD4\x81"
		"\xC3\xFF\xFF\x00\x00\x8B\x45\xE8\x4F\x83\x45\xEC\x02\x83\xC0\x04\x89\x45\xE8\x66\x85\xDB\x0F\x85\xF7\xFE\xFF\xFF\x8B\x5D\xF0\x83"
		"\x7D\xE0\x00\x8B\x75\xDC\x8B\x45\xFC\x8B\x7D\xF4\x8B\x4D\xF8\x74\x20\x85\xF6\x74\x1C\x83\x7D\xD8\x00\x74\x16\x85\xC0\x74\x12\x85"
		"\xFF\x74\x0E\x85\xDB\x74\x0A\x85\xC9\x74\x06\x83\x7D\xD4\x00\x75\x51\x8B\x55\xE4\x8B\x12\x3B\x95\x7C\xFF\xFF\xFF\x89\x55\xE4\x8B"
		"\x55\xE0\x0F\x85\x48\xFE\xFF\xFF\x85\xD2\x0F\x84\x75\x02\x00\x00\x85\xF6\x0F\x84\x6D\x02\x00\x00\x83\x7D\xD8\x00\x0F\x84\x63\x02"
		"\x00\x00\x85\xC0\x0F\x84\x5B\x02\x00\x00\x85\xFF\x0F\x84\x53\x02\x00\x00\x85\xDB\x0F\x84\x4B\x02\x00\x00\x85\xC9\x0F\x84\x43\x02"
		"\x00\x00\x8B\x45\xD4\x85\xC0\x0F\x84\x38\x02\x00\x00\x8B\x7D\x08\x8D\x8D\x78\xFF\xFF\xFF\x51\x6A\x01\xC7\x45\xEC\x00\x00\x00\x00"
		"\x33\xDB\x8B\x37\xC7\x45\xE8\x00\x00\x00\x00\xFF\xD0\x83\xFE\x02\x7C\x18\x8D\x45\xC8\xC7\x45\xC8\x5B\x57\x48\x5D\x50\xC7\x45\xCC"
		"\x20\x4C\x4C\x0A\x88\x5D\xD0\xFF\x55\xF0\x8D\x47\x18\x50\xFF\x55\xE0\x8B\xF8\x89\x7D\x80\x85\xFF\x0F\x84\xCC\x00\x00\x00\x83\xFE"
		"\x02\x7C\x1B\x8D\x45\xB0\xC7\x45\xB0\x5B\x57\x48\x5D\x50\xC7\x45\xB4\x20\x47\x50\x41\x66\xC7\x45\xB8\x0A\x00\xFF\x55\xF0\x8D\x45"
		"\xA4\x50\x57\xFF\x55\xDC\x89\x85\x7C\xFF\xFF\xFF\x85\xC0\x74\x75\x83\xFE\x02\x7C\x18\x8D\x45\xBC\xC7\x45\xBC\x5B\x57\x48\x5D\x50"
		"\xC7\x45\xC0\x20\x49\x49\x0A\x88\x5D\xC4\xFF\x55\xF0\x8B\x4D\x08\xFF\x71\x10\x8D\x79\x10\xC7\x45\xEC\x01\x00\x00\x00\xFF\x71\x08"
		"\x8D\x41\x08\xFF\x71\x04\x89\x45\x08\xFF\x95\x7C\xFF\xFF\xFF\x83\xC4\x0C\x89\x45\xE8\x83\xFE\x02\x7C\x3E\x85\xC0\xC7\x45\x98\x5B"
		"\x57\x48\x5D\xC7\x45\x9C\x20\x49\x49\x3A\x0F\x95\xC0\xC6\x45\xA0\x20\x04\x30\x66\xC7\x45\xA2\x0A\x00\x88\x45\xA1\x8D\x45\x98\x50"
		"\xFF\x55\xF0\xEB\x13\x8B\x45\xF4\xFF\xD0\x8B\xD8\x8B\x45\x08\x8D\x78\x10\x83\xC0\x08\x89\x45\x08\xFF\x75\x80\xFF\x55\xD8\x83\x7D"
		"\xE8\x00\x0F\x85\x06\x01\x00\x00\xEB\x13\x8B\x45\xF4\xFF\xD0\x8B\xD8\x8B\x45\x08\x8D\x78\x10\x83\xC0\x08\x89\x45\x08\x8B\x07\x8B"
		"\x7D\xF8\x85\xC0\x74\x03\x50\xFF\xD7\x8B\x45\x08\xFF\x30\xFF\xD7\x83\x7D\xEC\x00\x0F\x85\xD4\x00\x00\x00\x83\xFE\x01\x0F\x8C\xCB"
		"\x00\x00\x00\x8B\xCB\xC7\x45\x84\x5B\x57\x48\x5D\x83\xE1\x0F\xC7\x45\x88\x20\x45\x52\x52\x83\xF9\x0A\x66\xC7\x45\x8C\x3A\x20\x66"
		"\xC7\x45\x96\x0A\x00\x1A\xC0\x80\xC1\x37\x24\xF9\xC1\xEB\x04\x02\xC1\x8B\xCB\x88\x45\x95\x83\xE1\x0F\x83\xF9\x0A\x1A\xC0\xC1\xEB"
		"\x04\x24\xF9\x04\x37\x02\xC1\x8B\xCB\x88\x45\x94\x83\xE1\x0F\x83\xF9\x0A\x1A\xC0\xC1\xEB\x04\x24\xF9\x04\x37\x02\xC1\x8B\xCB\x88"
		"\x45\x93\x83\xE1\x0F\x83\xF9\x0A\x1A\xC0\xC1\xEB\x04\x24\xF9\x04\x37\x02\xC1\x8B\xCB\x88\x45\x92\x83\xE1\x0F\x83\xF9\x0A\x1A\xC0"
		"\xC1\xEB\x04\x24\xF9\x04\x37\x02\xC1\x8B\xCB\x88\x45\x91\x83\xE1\x0F\x83\xF9\x0A\x1A\xC0\xC1\xEB\x04\x24\xF9\x04\x37\x02\xC1\x8B"
		"\xCB\x88\x45\x90\x83\xE1\x0F\x83\xF9\x0A\x1A\xC0\x80\xC1\x37\x24\xF9\xC1\xEB\x04\x02\xC1\x83\xFB\x0A\x88\x45\x8F\x1A\xC0\x24\xF9"
		"\x04\x37\x02\xC3\x88\x45\x8E\x8D\x45\x84\x50\xFF\x55\xF0\x6A\x00\xFF\xB5\x78\xFF\xFF\xFF\xFF\x55\xD4\x8B\x45\xFC\x5F\x5E\x5B\x8B"
		"\xE5\x5D\xC2\x04\x00\x8B\x4D\xFC\x5F\x5E\x8B\xC1\x5B\x8B\xE5\x5D\xC2\x04\x00";

	constexpr SIZE_T x32APCShellcodeSize = sizeof(x32APCShellcode) - 1;

	const BYTE* x32Shellcode = x32APCShellcode + sizeof(PRE_X32SHELLCODE_ARGS_3_TO_1) - 1;
	constexpr SIZE_T x32ShellcodeSize = (sizeof(x32APCShellcode) - 1) - (sizeof(PRE_X32SHELLCODE_ARGS_3_TO_1) - 1);

#define PRE_X64SHELLCODE_VIRTUAL_FREE \
	"\x48\x83\xEC\x28"				   /* sub rsp,28               */ \
	"\xE8\x20\x00\x00\x00"			   /* call $+20                */ \
	"\x48\x83\xC4\x28"				   /* add rsp,28               */ \
	"\x48\x85\xC0"					   /* test rax,rax             */ \
	"\x75\x01"						   /* jne $+1                  */ \
	"\xC3"							   /* ret                      */ \
	"\x48\x8D\x0D\x00\x00\x00\x00"	   /* lea rcx,qword ptr ds:[$] */ \
	"\x66\x81\xE1\x00\xF0"		       /* and cx,F000              */ \
	"\x33\xD2"						   /* xor edx,edx              */ \
	"\x41\xB8\x00\x80\x00\x00"		   /* mov r8d,8000             */ \
	"\xFF\xE0"						   /* jmp rax                  */

	// The 64-bit InjectShellcode function from the project in the inject-shellcode subfolder.
	const BYTE x64Shellcode[] =
		PRE_X64SHELLCODE_VIRTUAL_FREE
		"\x48\x89\x4C\x24\x08\x55\x53\x56\x57\x41\x54\x41\x55\x41\x56\x41\x57\x48\x8D\x6C\x24\xE1\x48\x81\xEC\xD8\x00\x00\x00\x33\xFF\xC7"
		"\x45\x97\x49\x6E\x6A\x65\xC7\x45\x9B\x63\x74\x49\x6E\x44\x8B\xD7\x66\xC7\x45\x9F\x69\x74\x44\x8B\xDF\xC6\x45\xA1\x00\x44\x8B\xFF"
		"\x65\x48\x8B\x04\x25\x60\x00\x00\x00\x44\x8B\xF7\x48\x89\x7D\xEF\x8B\xF7\x48\x89\x7D\xCF\x44\x8B\xE7\x48\x89\x7D\xD7\x44\x8B\xEF"
		"\x48\x8B\x40\x18\x48\x83\xC0\x20\x48\x89\x7D\xDF\x48\x89\x7D\xFF\x48\x89\x7D\x77\x48\x89\x7D\xE7\x48\x8B\x18\x48\x89\x7D\xF7\x48"
		"\x89\x45\x07\x48\x89\x5D\x7F\x48\x3B\xD8\x0F\x84\x80\x04\x00\x00\x4C\x8B\x43\x50\x48\x8B\xC7\x44\x0F\xB7\x4B\x48\xBB\xFF\xFF\x00"
		"\x00\x0F\x1F\x40\x00\x66\x66\x66\x0F\x1F\x84\x00\x00\x00\x00\x00\x41\x0F\xB6\x08\x4D\x8D\x40\x01\xC1\xC8\x0D\x8B\xD0\x48\x03\xD1"
		"\x80\xF9\x61\x48\x8D\x42\xE0\x48\x0F\x42\xC2\x66\x44\x03\xCB\x75\xDF\x48\x8B\x5D\x7F\x3D\x5B\xBC\x4A\x6A\x0F\x85\x70\x01\x00\x00"
		"\x4C\x8B\x4B\x20\xBF\x08\x00\x00\x00\x49\x63\x41\x3C\x42\x8B\x84\x08\x88\x00\x00\x00\x49\x03\xC1\x48\x89\x45\x77\x44\x8B\x50\x20"
		"\x44\x8B\x58\x24\x4D\x03\xD1\x8B\x58\x18\x4D\x03\xD9\x0F\x1F\x00\x85\xDB\x0F\x84\x1A\x01\x00\x00\x41\x8B\x12\x49\x03\xD1\x33\xC0"
		"\x0F\xB6\x0A\x0F\x1F\x40\x00\x66\x0F\x1F\x84\x00\x00\x00\x00\x00\xC1\xC8\x0D\x48\x8D\x52\x01\x0F\xBE\xC9\x03\xC1\x0F\xB6\x0A\x84"
		"\xC9\x75\xED\x3D\xA4\x4E\x0E\xEC\x74\x35\x3D\xAA\xFC\x0D\x7C\x74\x2E\x3D\xA0\xD5\xC9\x4D\x74\x27\x3D\xAC\x33\x06\x03\x74\x20\x3D"
		"\x66\x19\xDA\x75\x74\x19\x3D\xBC\x22\x0D\x47\x74\x12\x3D\xFB\x97\xFD\x0F\x74\x0B\x3D\x7C\xC4\x22\x59\x0F\x85\xA0\x00\x00\x00\x48"
		"\x8B\x4D\x77\x45\x0F\xB7\x03\x8B\x51\x1C\x49\x03\xD1\x3D\xA4\x4E\x0E\xEC\x75\x0D\x42\x8B\x04\x82\x49\x03\xC1\x48\x89\x45\xCF\xEB"
		"\x76\x3D\xAA\xFC\x0D\x7C\x75\x0D\x42\x8B\x04\x82\x49\x03\xC1\x48\x89\x45\xD7\xEB\x62\x3D\xA0\xD5\xC9\x4D\x75\x0D\x42\x8B\x04\x82"
		"\x49\x03\xC1\x48\x89\x45\xDF\xEB\x4E\x3D\xAC\x33\x06\x03\x75\x09\x46\x8B\x3C\x82\x4D\x03\xF9\xEB\x3E\x3D\x66\x19\xDA\x75\x75\x09"
		"\x46\x8B\x34\x82\x4D\x03\xF1\xEB\x2E\x3D\xBC\x22\x0D\x47\x75\x09\x42\x8B\x34\x82\x49\x03\xF1\xEB\x1E\x3D\xFB\x97\xFD\x0F\x75\x09"
		"\x46\x8B\x24\x82\x4D\x03\xE1\xEB\x0E\x3D\x7C\xC4\x22\x59\x75\x07\x46\x8B\x2C\x82\x4D\x03\xE9\xB8\xFF\xFF\x00\x00\x66\x03\xF8\x49"
		"\x83\xC2\x04\x49\x83\xC3\x02\xFF\xCB\x66\x85\xFF\x0F\x85\xDE\xFE\xFF\xFF\x4C\x8B\x55\xD7\x33\xFF\x4C\x8B\x5D\xDF\x48\x8B\x5D\x7F"
		"\x4C\x89\x6D\xF7\x4C\x89\x65\xE7\x4C\x89\x7D\xFF\x48\x89\x75\x77\x48\x8B\x4D\xCF\x48\x85\xC9\x74\x23\x4D\x85\xD2\x74\x1E\x4D\x85"
		"\xDB\x74\x19\x4D\x85\xFF\x74\x14\x4D\x85\xF6\x74\x0F\x48\x85\xF6\x74\x0A\x4D\x85\xE4\x74\x05\x4D\x85\xED\x75\x59\x48\x8B\x1B\x48"
		"\x89\x5D\x7F\x48\x3B\x5D\x07\x0F\x85\x03\xFE\xFF\xFF\x48\x85\xC9\x0F\x84\x7A\x02\x00\x00\x4D\x85\xD2\x0F\x84\x71\x02\x00\x00\x4D"
		"\x85\xDB\x0F\x84\x68\x02\x00\x00\x4D\x85\xFF\x0F\x84\x5F\x02\x00\x00\x4D\x85\xF6\x0F\x84\x56\x02\x00\x00\x48\x85\xF6\x0F\x84\x4D"
		"\x02\x00\x00\x4D\x85\xE4\x0F\x84\x44\x02\x00\x00\x4D\x85\xED\x0F\x84\x3B\x02\x00\x00\x48\x8B\x45\x67\x48\x8D\x55\x6F\xB9\x01\x00"
		"\x00\x00\x44\x8B\xFF\x8B\x18\x41\xFF\xD5\x83\xFB\x02\x7C\x1C\x48\x8D\x4C\x24\x20\xC7\x44\x24\x20\x5B\x57\x48\x5D\xC7\x44\x24\x24"
		"\x20\x4C\x4C\x0A\xC6\x44\x24\x28\x00\xFF\xD6\x4C\x8B\x6D\x67\x48\x8B\x45\xCF\x49\x8D\x4D\x18\xFF\xD0\x4C\x8B\xE0\x48\x85\xC0\x0F"
		"\x84\xD0\x00\x00\x00\x83\xFB\x02\x7C\x1A\x48\x8D\x4D\x87\xC7\x45\x87\x5B\x57\x48\x5D\xC7\x45\x8B\x20\x47\x50\x41\x66\xC7\x45\x8F"
		"\x0A\x00\xFF\xD6\x48\x8D\x55\x97\x49\x8B\xCC\xFF\x55\xD7\x4C\x8B\xE8\x48\x85\xC0\x74\x79\x83\xFB\x02\x7C\x1C\x48\x8D\x4C\x24\x30"
		"\xC7\x44\x24\x30\x5B\x57\x48\x5D\xC7\x44\x24\x34\x20\x49\x49\x0A\xC6\x44\x24\x38\x00\xFF\xD6\x48\x8B\x45\x67\x4C\x8B\x40\x10\x48"
		"\x8D\x70\x10\x48\x8B\x50\x08\x4C\x8D\x70\x08\xC7\x45\xEF\x01\x00\x00\x00\x8B\x48\x04\x41\xFF\xD5\x4C\x8B\x6D\x77\x44\x8B\xF8\x83"
		"\xFB\x02\x7C\x40\x85\xC0\xC7\x45\xA7\x5B\x57\x48\x5D\x48\x8D\x4D\xA7\xC7\x45\xAB\x20\x49\x49\x3A\x0F\x95\xC0\xC6\x45\xAF\x20\x04"
		"\x30\x66\xC7\x45\xB1\x0A\x00\x88\x45\xB0\x41\xFF\xD5\xEB\x15\x41\xFF\xD6\x4C\x8B\x6D\x77\x8B\xF8\x48\x8B\x45\x67\x48\x8D\x70\x10"
		"\x4C\x8D\x70\x08\x49\x8B\xCC\xFF\x55\xDF\x45\x85\xFF\x0F\x85\x0F\x01\x00\x00\xEB\x11\x41\xFF\xD6\x49\x8D\x75\x10\x8B\xF8\x4D\x8D"
		"\x75\x08\x4C\x8B\x6D\x77\x48\x8B\x0E\x48\x8B\x75\xE7\x48\x85\xC9\x74\x02\xFF\xD6\x49\x8B\x0E\xFF\xD6\x83\x7D\xEF\x00\x0F\x85\xDF"
		"\x00\x00\x00\x83\xFB\x01\x0F\x8C\xD6\x00\x00\x00\x8B\xCF\xC7\x45\xB7\x5B\x57\x48\x5D\x83\xE1\x0F\xC7\x45\xBB\x20\x45\x52\x52\x83"
		"\xF9\x0A\x66\xC7\x45\xBF\x3A\x20\xBA\x30\x00\x00\x00\x66\xC7\x45\xC9\x0A\x00\x41\xB8\x37\x00\x00\x00\x8B\xC2\x41\x0F\x43\xC0\xC1"
		"\xEF\x04\x02\xC1\x8B\xCF\x83\xE1\x0F\x88\x45\xC8\x83\xF9\x0A\x8B\xC2\x41\x0F\x43\xC0\xC1\xEF\x04\x02\xC1\x8B\xCF\x83\xE1\x0F\x88"
		"\x45\xC7\x83\xF9\x0A\x8B\xC2\x41\x0F\x43\xC0\xC1\xEF\x04\x02\xC1\x8B\xCF\x83\xE1\x0F\x88\x45\xC6\x83\xF9\x0A\x8B\xC2\x41\x0F\x43"
		"\xC0\xC1\xEF\x04\x02\xC1\x8B\xCF\x83\xE1\x0F\x88\x45\xC5\x83\xF9\x0A\x8B\xC2\x41\x0F\x43\xC0\xC1\xEF\x04\x02\xC1\x8B\xCF\x83\xE1"
		"\x0F\x88\x45\xC4\x83\xF9\x0A\x8B\xC2\x41\x0F\x43\xC0\xC1\xEF\x04\x02\xC1\x8B\xCF\x83\xE1\x0F\x88\x45\xC3\x83\xF9\x0A\x8B\xC2\x41"
		"\x0F\x43\xC0\xC1\xEF\x04\x02\xC1\x83\xE7\x0F\x83\xFF\x0A\x88\x45\xC2\x48\x8D\x4D\xB7\x41\x0F\x43\xD0\x40\x02\xD7\x88\x55\xC1\x41"
		"\xFF\xD5\x8B\x4D\x6F\x33\xD2\xFF\x55\xF7\x48\x8B\x45\xFF\xEB\x03\x49\x8B\xC7\x48\x81\xC4\xD8\x00\x00\x00\x41\x5F\x41\x5E\x41\x5D"
		"\x41\x5C\x5F\x5E\x5B\x5D\xC3";

	constexpr SIZE_T x64ShellcodeSize = sizeof(x64Shellcode) - 1;

	//
	// https://docs.microsoft.com/en-us/windows/win32/sysinfo/verifying-the-system-version
	//
	BOOL CheckWindowsVersion(DWORD dwMajorVersion, DWORD dwMinorVersion,
		WORD wServicePackMajor, WORD wServicePackMinor, int op)
	{
		// Initialize the OSVERSIONINFOEX structure
		OSVERSIONINFOEX osvi;

		ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
		osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
		osvi.dwMajorVersion = dwMajorVersion;
		osvi.dwMinorVersion = dwMinorVersion;
		osvi.wServicePackMajor = wServicePackMajor;
		osvi.wServicePackMinor = wServicePackMinor;

		// Initialize the type mask
		DWORD dwTypeMask = VER_MAJORVERSION | VER_MINORVERSION |
			VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR;

		// Initialize the condition mask
		DWORDLONG dwlConditionMask = 0;

		VER_SET_CONDITION(dwlConditionMask, VER_MAJORVERSION, op);
		VER_SET_CONDITION(dwlConditionMask, VER_MINORVERSION, op);
		VER_SET_CONDITION(dwlConditionMask, VER_SERVICEPACKMAJOR, op);
		VER_SET_CONDITION(dwlConditionMask, VER_SERVICEPACKMINOR, op);

		// Perform the test
		return VerifyVersionInfo(&osvi, dwTypeMask, dwlConditionMask);
	}

	//
	// Based on:
	// http://securityxploded.com/ntcreatethreadex.php
	//
	HANDLE MyCreateRemoteThread(HANDLE hProcess,
		LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, USHORT targetProcessArch)
	{
#ifndef _WIN64
		if (targetProcessArch == IMAGE_FILE_MACHINE_AMD64) {
			// WOW64 to x64 native, use heaven's gate.
			return (HANDLE)CreateRemoteThread64(
				HANDLE_TO_DWORD64(hProcess), PTR_TO_DWORD64(lpStartAddress), PTR_TO_DWORD64(lpParameter));
		}
#endif // _WIN64

		using NtCreateThreadEx_t = NTSTATUS(WINAPI*)(
			OUT PHANDLE hThread,
			IN ACCESS_MASK DesiredAccess,
			IN LPVOID ObjectAttributes,
			IN HANDLE ProcessHandle,
			IN LPTHREAD_START_ROUTINE lpStartAddress,
			IN LPVOID lpParameter,
			IN BOOL CreateSuspended,
			IN ULONG_PTR StackZeroBits,
			IN ULONG_PTR SizeOfStackCommit,
			IN ULONG_PTR SizeOfStackReserve,
			OUT LPVOID lpBytesBuffer
			);

		static NtCreateThreadEx_t pNtCreateThreadEx = []() {
			// Only needed for Windows Vista and 7.
			if (CheckWindowsVersion(6, 0, 0, 0, VER_GREATER_EQUAL) &&
				!CheckWindowsVersion(6, 2, 0, 0, VER_GREATER_EQUAL)) {
				HMODULE hNtdll = GetModuleHandle(L"ntdll.dll");
				if (hNtdll) {
					return (NtCreateThreadEx_t)GetProcAddress(hNtdll, "NtCreateThreadEx");
				}
			}

			return (NtCreateThreadEx_t)nullptr;
		}();

		LPSECURITY_ATTRIBUTES lpThreadAttributes = nullptr;
		DWORD dwCreationFlags = 0;

		if (pNtCreateThreadEx) {
			HANDLE hThread;
			ULONG_PTR bOutBuffer1[2];
			ULONG_PTR bOutBuffer2[1];
			struct {
				ULONG_PTR Size;
				ULONG_PTR Unknown1;
				ULONG_PTR nBuf1Size;
				void* pBuf1;
				ULONG_PTR Unknown2;
				ULONG_PTR Unknown3;
				ULONG_PTR nBuf2Size;
				void* pBuf2;
				ULONG_PTR Unknown4;
			} param = { sizeof(param), 0x10003, sizeof(ULONG_PTR) * 2, bOutBuffer1, 0, 0x10004, sizeof(ULONG_PTR), bOutBuffer2, 0 };

			NTSTATUS result = pNtCreateThreadEx(&hThread, 0x1FFFFF, lpThreadAttributes,
				hProcess, lpStartAddress, lpParameter, (dwCreationFlags & CREATE_SUSPENDED) ? TRUE : FALSE, 0, 0, 0, &param);
			if (result < 0) {
				SetLastError(LsaNtStatusToWinError(result));
				return nullptr;
			}

			return hThread;
		}

		return CreateRemoteThread(hProcess, lpThreadAttributes, 0, lpStartAddress, lpParameter, dwCreationFlags, nullptr);
	}

	//
	// Reference: https://repnz.github.io/posts/apc/wow64-user-apc/
	//
	ULONG64 EncodeWow64ApcRoutine(ULONG64 ApcRoutine)
	{
		return (ULONG64)((-(INT64)ApcRoutine) << 2);
	}

	//
	// Reference: https://repnz.github.io/posts/apc/user-apc/
	//
	BOOL MyQueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData, USHORT targetProcessArch)
	{
#ifndef _WIN64
		if (targetProcessArch == IMAGE_FILE_MACHINE_AMD64) {
			// WOW64 to x64 native, use heaven's gate.
			//
			// "Microsoft added a validation to prevent a programming error:
			// If you try to queue an APC from a 32 bit process to a 64 bit
			// process and you use a 32 bit address, you'll get this status code:
			// [...] STATUS_INVALID_HANDLE"
			// https://repnz.github.io/posts/apc/wow64-user-apc/
			return NtQueueApcThread64(
				HANDLE_TO_DWORD64(hThread), PTR_TO_DWORD64(pfnAPC), (DWORD64)dwData, 0, 0);
		}
#endif // _WIN64

		using NtQueueApcThread_t = DWORD(WINAPI*)(
			IN HANDLE ThreadHandle,
			IN PVOID ApcDispatchRoutine,
			IN ULONG_PTR SystemArgument1,
			IN ULONG_PTR SystemArgument2,
			IN ULONG_PTR SystemArgument3
			);

		static NtQueueApcThread_t pNtQueueApcThread = []() {
			HMODULE hNtdll = GetModuleHandle(L"ntdll.dll");
			if (hNtdll) {
				return (NtQueueApcThread_t)GetProcAddress(hNtdll, "NtQueueApcThread");
			}

			return (NtQueueApcThread_t)nullptr;
		}();

		if (!pNtQueueApcThread) {
			SetLastError(ERROR_PROC_NOT_FOUND);
			return FALSE;
		}

#ifdef _WIN64
		if (targetProcessArch == IMAGE_FILE_MACHINE_I386) {
			// x64 native to WOW64, encode address.
			pfnAPC = (PAPCFUNC)EncodeWow64ApcRoutine((ULONG64)pfnAPC);
		}
#endif // _WIN64

		NTSTATUS result = pNtQueueApcThread(hThread, pfnAPC, dwData, 0, 0);
		if (result < 0) {
			SetLastError(LsaNtStatusToWinError(result));
			return FALSE;
		}

		return TRUE;
	}

	USHORT GetProcessArch(HANDLE hProcess)
	{
		// For now, only IMAGE_FILE_MACHINE_I386 and IMAGE_FILE_MACHINE_AMD64.
		// TODO: Use IsWow64Process2 if available.

#ifndef _WIN64
		SYSTEM_INFO siSystemInfo;
		GetNativeSystemInfo(&siSystemInfo);
		if (siSystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {
			// 32-bit machine, only one option.
			return IMAGE_FILE_MACHINE_I386;
		}
#endif // _WIN64

		BOOL bIsWow64Process;
		if (IsWow64Process(hProcess, &bIsWow64Process) && bIsWow64Process) {
			return IMAGE_FILE_MACHINE_I386;
		}

		return IMAGE_FILE_MACHINE_AMD64;
	}

	std::filesystem::path GetEnginePath(USHORT machine)
	{
		std::filesystem::path libraryPath = wil::GetModuleFileName<std::wstring>(g_hDllInst);

		auto folderPath = libraryPath.parent_path();
		auto folderName = folderPath.filename();

		if (folderName != L"32" && folderName != L"64") {
			throw std::runtime_error("DLL file not in \\32 or \\64 folder");
		}

		PCWSTR newFolderName;
		switch (machine) {
		case IMAGE_FILE_MACHINE_I386:
			newFolderName = L"32";
			break;

		case IMAGE_FILE_MACHINE_AMD64:
			newFolderName = L"64";
			break;

		default:
			throw std::logic_error("Unknown architecture");
		}

		return folderPath.parent_path() / newFolderName;
	}
}

namespace DllInject
{
	void DllInject(HANDLE hProcess, HANDLE hThreadForAPC, HANDLE hSessionManagerProcess, HANDLE hSessionMutex)
	{
		const BYTE* shellcode;
		size_t shellcodeSize;

		USHORT targetProcessArch = GetProcessArch(hProcess);
		switch (targetProcessArch) {
		case IMAGE_FILE_MACHINE_I386:
			if (hThreadForAPC) {
				// The calling convention is different - three arguments instead of one.
				shellcode = x32APCShellcode;
				shellcodeSize = x32APCShellcodeSize;
			}
			else {
				shellcode = x32Shellcode;
				shellcodeSize = x32ShellcodeSize;
			}
			break;

		case IMAGE_FILE_MACHINE_AMD64:
			shellcode = x64Shellcode;
			shellcodeSize = x64ShellcodeSize;
			break;

		default:
			throw std::logic_error("Invalid architecture value");
		}

		std::wstring dllPath = GetEnginePath(targetProcessArch) / L"global-inject-lib.dll";
		size_t dllPathBytes = (dllPath.length() + 1) * sizeof(WCHAR);

		HANDLE hRemoteSessionManagerProcess;
		THROW_IF_WIN32_BOOL_FALSE(DuplicateHandle(GetCurrentProcess(), hSessionManagerProcess, hProcess, &hRemoteSessionManagerProcess,
			PROCESS_DUP_HANDLE | PROCESS_QUERY_LIMITED_INFORMATION | SYNCHRONIZE, FALSE, 0));

		auto remoteSessionManagerProcessCleanup = wil::scope_exit([hProcess, hRemoteSessionManagerProcess] {
			DuplicateHandle(hProcess, hRemoteSessionManagerProcess, nullptr, nullptr, 0, FALSE, DUPLICATE_CLOSE_SOURCE);
		});

		HANDLE hRemoteSessionMutex = nullptr;
		if (hSessionMutex) {
			THROW_IF_WIN32_BOOL_FALSE(DuplicateHandle(GetCurrentProcess(), hSessionMutex, hProcess, &hRemoteSessionMutex,
				PROCESS_QUERY_LIMITED_INFORMATION, FALSE, 0));
		}

		auto remoteSessionMutexCleanup = wil::scope_exit([hProcess, hRemoteSessionMutex] {
			if (hRemoteSessionMutex) {
				DuplicateHandle(hProcess, hRemoteSessionMutex, nullptr, nullptr, 0, FALSE, DUPLICATE_CLOSE_SOURCE);
			}
		});

		size_t shellcodeDataSize = offsetof(LOAD_LIBRARY_REMOTE_DATA, szDllName) + dllPathBytes;
		auto shellcodeDataVector = std::vector<BYTE>(shellcodeDataSize);
		auto shellcodeData = reinterpret_cast<LOAD_LIBRARY_REMOTE_DATA*>(shellcodeDataVector.data());

		shellcodeData->nLogVerbosity = 2;
		shellcodeData->bRunningFromAPC = !!hThreadForAPC;
		shellcodeData->hSessionManagerProcess = hRemoteSessionManagerProcess;
		shellcodeData->hSessionMutex = hRemoteSessionMutex;
		memcpy(shellcodeData->szDllName, dllPath.c_str(), dllPathBytes);

		size_t shellcodeSizeAligned = (shellcodeSize + (sizeof(LONG_PTR) - 1)) & ~(sizeof(LONG_PTR) - 1);

		// Allocate enough memory in the remote process's address space
		// to hold the shellcode and the data struct.
		void* pRemoteCode = VirtualAllocEx(
			hProcess, nullptr, shellcodeSizeAligned + shellcodeDataSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		THROW_LAST_ERROR_IF_NULL(pRemoteCode);

		auto remoteCodeCleanup = wil::scope_exit([hProcess, pRemoteCode] {
			VirtualFreeEx(hProcess, pRemoteCode, 0, MEM_RELEASE);
		});

		// Write our shellcode into the remote process.
		THROW_IF_WIN32_BOOL_FALSE(WriteProcessMemory(hProcess, pRemoteCode, shellcode, shellcodeSize, nullptr));

		// Write a copy of our struct to the remote process.
		void* pRemoteData = reinterpret_cast<BYTE*>(pRemoteCode) + shellcodeSizeAligned;
		THROW_IF_WIN32_BOOL_FALSE(WriteProcessMemory(hProcess, pRemoteData, shellcodeData, shellcodeDataSize, nullptr));

		// Mark shellcode as executable.
		DWORD oldProtect;
		THROW_IF_WIN32_BOOL_FALSE(VirtualProtectEx(hProcess, pRemoteCode, shellcodeSize, PAGE_EXECUTE_READ, &oldProtect));

		if (hThreadForAPC) {
			THROW_IF_WIN32_BOOL_FALSE(MyQueueUserAPC(
				reinterpret_cast<PAPCFUNC>(pRemoteCode), hThreadForAPC, reinterpret_cast<ULONG_PTR>(pRemoteData), targetProcessArch));
		}
		else {
			wil::unique_process_handle hRemoteThread(MyCreateRemoteThread(hProcess,
				reinterpret_cast<LPTHREAD_START_ROUTINE>(pRemoteCode), pRemoteData, targetProcessArch));
			THROW_LAST_ERROR_IF_NULL(hRemoteThread);
		}

		remoteSessionManagerProcessCleanup.release();
		remoteSessionMutexCleanup.release();
		remoteCodeCleanup.release();
	}
}
